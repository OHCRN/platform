# Prisma Schema and Postgres Migrations in Development

This document is intended to record a few recommendations and gotchas when working with database migrations and the `pnpm prisma migrate-dev` command. Please note, this applies to local development only; production environment migrations are handled with a [different process](https://www.prisma.io/docs/concepts/components/prisma-migrate/migrate-development-production#production-and-testing-environments).

## Creating new migrations

Migrations are generated by making a change to [`schema.prisma`](./schema.prisma) file, then running the `pnpm prisma migrate dev` command. There are a couple important things to note:

- running the above command will auto-generate a new `migration.sql` file **AND** apply it to the database
- in the case of renaming a field/model, the generated sql queries will default to **dropping the column or table**, possibly resulting in data loss

**Because of this default behaviour, it is best to use the `--create-only` flag when making any schema changes**.

You can use the `--create-only` flag like so:

```sh
% pnpm prisma migrate dev --create-only --name my-migration
```

This will create a `migration.sql` file in a named folder inside the [`migrations`](./migrations/) folder, but will not apply it to the database. You can then view and edit the generated SQL before applying it to the database. This approach is also useful in working out the precise changes needed in the `schema.prisma` file to generate the desired SQL, without requiring extra customization.

Once you've verified the migration, you can apply it via:

```sh
% pnpm prisma migrate dev
```

Keep in mind that when editing the generated SQL file, it will need to match the schema changes you've made.

### Example Custom Migration

For example, if you are renaming a model `Post`:

> **schema.prisma**

```prisma
model Post {
  id       String @id @default(cuid())
  title    String @unique
  subject  String
}
```

to `Article`:

> **schema.prisma**

```prisma
model Article {
  id       String @id @default(cuid())
  title    String @unique
  subject  String
}
```

In your shell, run:

```sh
% prisma migrate dev --create-only --name rename-post-to-article
```

You should see this response in your shell:

```sh
Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": PostgreSQL database "mydb", schema "public" at "localhost:5432"


⚠️  Warnings for the current datasource:

  • You are about to drop the `Post` table, which is not empty (1 rows).

Are you sure you want create this migration? (y/N)
```

Respond `yes` to the prompt:

```sh
✔ Are you sure you want create this migration? … yes
```

And you will see:

```sh
Prisma Migrate created the following migration without applying it 20230628161622_rename_post_to_article

You can now edit it and apply it by running prisma migrate dev.
```

Prisma will then generate the following SQL:

```sql
-- DropTable
DROP TABLE Post;

-- CreateTable
CREATE TABLE "Article" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "subject" TEXT NOT NULL
    CONSTRAINT "Article_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Article_title_key" ON "Article"("title");
```

If instead you would like to simply rename the table, the migration should be edited to this:

```sql
-- DropIndex
DROP INDEX "Post_title_key";
-- DropConstraint
ALTER TABLE "Post" DROP CONSTRAINT "Post_pkey";

-- AlterTable
ALTER TABLE "Post" RENAME TO "Article";

-- AddConstraint
ALTER TABLE "Article" ADD CONSTRAINT "Article_pkey" PRIMARY KEY ("id");

-- CreateIndex
CREATE UNIQUE INDEX "Article_title_key" ON "Article"("title");
```

If your custom SQL does not entirely match the `schema.prisma` model, (for example, if in the above code you renamed the table but did not alter the constraints) the Prisma migrate process will generate a subsequent migration to account for any missing changes.

If there are any syntax errors, the migration should fail to execute.
